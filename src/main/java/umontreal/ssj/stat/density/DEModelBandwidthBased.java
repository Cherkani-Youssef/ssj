package umontreal.ssj.stat.density;

import java.util.ArrayList;

import umontreal.ssj.functionfit.LeastSquares;
import umontreal.ssj.hups.RQMCPointSet;
import umontreal.ssj.mcqmctools.MonteCarloModelDensityKnown;
import umontreal.ssj.mcqmctools.MonteCarloModelDouble;
import umontreal.ssj.mcqmctools.RQMCExperiment;
import umontreal.ssj.probdist.NormalDist;
import umontreal.ssj.stat.Tally;
import umontreal.ssj.util.PrintfFormat;

/**
 * Implements a parametric model that is particularly designed for the
 * estimation of the density of a random variable \f$X = g(\mathbf U)\f$, where
 * \f$\mathbf U = (U_1,U_2,\dots,U_d)\sim U(0,1)^d \f$ with a given function
 * \f$g:(0,1)^d\rightarrow\mathbb{R}\f$ over a finite interval \f$[a,b]\f$. Such
 * situations arise naturally in uncertainty quantification. The observations
 * \f$X_0,X_1,\dots,X_n\f$ which are used to construct the density will
 * typically be generated by simulation of \f$\mathbf U\f$, either by Monte
 * Carlo (MC) or by randomized quasi-Monte Carlo (RQMC).
 * 
 * The model applies to density estimators that rely on the selection of a
 * bandwidth (or binwidth) such as histogram estimators, see @ref DEHistogram,
 * and kernel density estimators (KDEs), see
 * 
 * \ref DEKernelDensity, for instance. It is thoroughly investigated in (TODO:
 * cite our paper) and can be explained as follows. It is known in general, that
 * the mean integrated square error (MISE) can be rewritten as the sum of the
 * integrated variance (IV) and the integrated square bias
 * 
 * @f[ \textrm{MISE} = \int_a^b\mathbb{E} [\hat{f}_{n,h}(x) - f(x)]^2\mathrm{d}x
 * = \int_a^b\textrm{Var}[\hat{f}_{n,h}(x)]\mathrm{d}x + \int_a^b \left(
 * \mathbb{E}[\hat{f}_{n,h}(x)] - f(x) \right)^2\mathrm{d}x = \textrm{IV} +
 * \textrm{ISB}, @f]
 * 
 * where \f$f\f$ denotes the true density and \f$\hat{f}_{n,h}\f$ the density
 * estimator. For MC it is known that, asymptotically, \f$\textrm{IV}\approx C
 * n^{-1} h^{-1}\f$ and \f$\textrm{ISB}\approx B h^{\alpha}\f$,
 * \f$C,B,\alpha>0\f$. Observe that the power of \f$h\f$ is positive in the ISB,
 * while it appears to be negative in the IV.
 * 
 * The goal is to select an optimal band- or binwidth \f$h_*\f$ which balances
 * these two terms, which is also known as the infamous <em>variance-bias
 * tradeoff</em>. This is possible, as soon as all the parameters
 * \f$C,B,\alpha\f$ are explicitly known (or can be sufficiently well estimated,
 * at least). For histograms and KDEs this is indeed the case. Let \f$R(g)\f$
 * denote the roughness functional over the interval \f$[a,b]\f$ and let
 * \f$\mu_k(g)\f$ be the \f$k\f$-th moment of a function \f$g\f$, i.e.
 * 
 * \f[ R(g) = \int_a^bg^2(x)\mathrm{d}x,\qquad\text{and}\quad
 * \mu_k(g)=\int_{-\infty}^{\infty}x^kg(x)\mathrm{d}x. \f]
 * 
 * Assuming that all the entities exist and are finite, the table below lists
 * the parameter values for histograms and KDEs for observations generated with
 * MC, see \cite tSCO15a.
 * 
 * <center>
 * <table>
 * <caption id="mc_parameters"> Asymptotically optimal parameter values with
 * MC</caption>
 * <tr>
 * <th>Parameter
 * <th>Histogram
 * <th>KDE
 * <tr>
 * <td>@f$C@f$
 * <td>1
 * <td>@f$\mu_0(K^2)@f$
 * <tr>
 * <td>@f$\alpha@f$
 * <td>2
 * <td>4
 * <tr>
 * <td>@f$B@f$
 * <td>@f$R(f')/12@f$
 * <td>@f$ \mu_2^2(K) R(f'')/4@f$
 * </table>
 * </center>
 * 
 * The only highly unpleasant quantities are the roughness functional of the
 * first or second derivative of the unknown density. This, however, can be
 * overcome by using derivative estimates as implemented in \ref
 * DensityDerivativeEstimator and plugging the results back into the expression
 * for the ISB. The kernel assumed for the derivative estimation is a standard
 * normal. To estimate the \f$h^{r_0}_{\text{AMISE}} \f$, where \f$r_0\f$ can be
 * seen in the table above, we use one step of the recursion
 * DensityDerivativeEstimator#hAmiseR(int, int, double, double[], double,
 * DensityDerivativeEstimator, double[], double[], double, double). For the
 * initial value we estimate the empirical standard deviation \f$\hat{\sigma}\f$
 * from the observations \f$X_0,\dots,X_{n-1}\f$ and assume \f$f\f$ to be a
 * normal distribution with standard deviation \f$\hat{\sigma}\f$.
 * 
 * If the user wishes to use different kernels or other initial values than
 * those stated above, it is only necessary to overwrite the corresponding
 * methods for estimating \f$B\f$. The rest will remain intact.
 * 
 * Let us now turn to the IV. What changes with RQMC is that it can cause
 * significant variance reduction, which, however, can come at price of a worse
 * dependency on \f$h\f$. This was proven in (TODO: cite our paper)
 * theoretically and also observed empirically. To reflect this behavior, we
 * choose the model
 * 
 * \f[ \textrm{IV}\approx C n^{-\beta}h^{-\delta},\qquad \beta,\delta>1, \f]
 * 
 * locally, i.e. within a small region w.r.t. \f$(n,h)\f$. This proved to be a
 * reasonable assumption.
 * 
 * Observe that taking the logarithm of both sides of the above model assumption
 * yields a linear model with variables \f$\log n\f$ and \f$\log h\f$, and
 * unknown parameters \f$\log C,\beta,\delta\f$. Based on this linear model, one
 * can estimate the empirical IV for several reasonable values of \f$(n,h)\f$
 * with the methods provided by \ref DensityEstimator and subsequently obtain
 * estimates for the unknown parameters. Together with the estimated parameters
 * from the ISB, one can thus compute an estimate for \f$h_*\f$.
 * 
 * Finally, one can test the estimator with the selected \f$h_*\f$ out of the
 * box, estimate its empirical IV, compute its modeled ISB and add these
 * quantities to obtain an estimator for the empirical MISE.
 * 
 * 
 */

public class DEModelBandwidthBased  {

	/** Power of \f$h\f$ in ISB */
	private double alpha;
	/** Multiplicative constant in ISB */
	private double B;
	/** Negative power of \f$n\f$ in IV */
	private double beta;
	/** Multiplicative constant in IV */
	private double C;
	/** Negative power of \f$h\f$ in IV */
	private double delta;

	/**
	 * left boundary of the interval over which we estimate.
	 */
	private double a;
	/**
	 * right boundary of the interval over which we estimate.
	 */
	private double b;
	/**
	 * flag whether to display output during running experiment or not.
	 */
	protected boolean displayExec = false;

	/**
	 * base of all logarithms used in the experiment. Defaults to 2.
	 */
	protected double baseOfLog = 2.0;
	
	private double logOfBase = Math.log(2.0);

	/**
	 * logarithms in base #baseOfLog of the number of points.
	 */
	protected double[] logN;

	/**
	 * logarithms in base #baseOfLog of the bin-/bandwidths.
	 */
	protected double[] logH;

	/**
	 * The estimated empirical IV of the estimator for the pairs (n,h) in the
	 * testing region #logN \f$\times\f$ #logH.
	 */
	protected double[] logIV3D;

	protected double[] logIV;
	protected double[] logISB;
	protected double[] logMISE;

	protected double[] logEstIV;
	protected double[] logEstISB;
	protected double[] logEstMISE;

	/**
	 * Constructs an instance of this parametric model. The density estimator \a de
	 * is only used to determine the value for \f$\alpha\f$ and does currently only
	 * work with \ref DEHistogram and \ref DEKernelDensity. In any other case refer
	 * to #DEModelBandwidthBased(double, MonteCarloModelDouble, double, double).
	 * 
	 * @param de
	 *            the density estimator to obtain \f$\alpha\f$.
	 * @param a
	 *            left boundary of the interval over which we estimate.
	 * @param b
	 *            right boundary of the interval over which we estimate.
	 */
	public DEModelBandwidthBased(DensityEstimator de, double a, double b) {

		setRange(a, b);
		setAlpha(de);
	}

	/**
	 * Constructs an instance of this parametric model.
	 * 
	 * @param alpha
	 *            the value for \f$\alpha\f$ used.
	 * @param a
	 *            left boundary of the interval over which we estimate.
	 * @param b
	 *            right boundary of the interval over which we estimate.
	 */
	public DEModelBandwidthBased(double alpha, double a, double b) {
		this.alpha = alpha;
		setRange(a, b);
	}

	/**
	 * Sets #displayExec, i.e. the flag whether to display output during running
	 * experiment or not to \a displayExec.
	 * 
	 * @param displayExec
	 *            flag, whether display output during running experiment or not.
	 */
	public void setDisplayExec(boolean displayExec) {
		this.displayExec = displayExec;
	}

	/**
	 * Gives #displayExec, i.e. the flag whether to display output during running
	 * experiment or not.
	 * 
	 * @return flag, whether to display output during running experiment or not.
	 */
	public boolean getDisplayExec() {
		return displayExec;
	}

	/**
	 * Sets the current interval over which we estimate to \f$[a,b]\f$.
	 * 
	 * @param a
	 *            left boundary of the interval over which we estimate.
	 * @param b
	 *            right boundary of the interval over which we estimate.
	 */
	public void setRange(double a, double b) {
		this.a = a;
		this.b = b;
	}

	/**
	 * Gives the left boundary of the interval over which we estimate.
	 * 
	 * @return the left boundary of the interval over which we estimate.
	 */
	public double geta() {
		return a;
	}

	/**
	 * Gives the right boundary of the interval over which we estimate.
	 * 
	 * @return the right boundary of the interval over which we estimate.
	 */
	public double getb() {
		return b;
	}

	/**
	 * Gives the current value of \f$alpha\f$.
	 * 
	 * @return \f$\alpha\f$.
	 */
	public double getAlpha() {
		return alpha;
	}

	/**
	 * Sets the current value of \f$\alpha\f$ to \a alpha.
	 * 
	 * @param alpha
	 *            the desired value for \f$\alpha\f$.
	 */
	public void setAlpha(double alpha) {
		this.alpha = alpha;
	}
	
	/**
	 * Sets the current value of \f$\alpha\f$ to 2.
	 * @param de
	 */
	public void setAlpha(DEHistogram de) {
		setAlpha(2.0);
	}
	
	/**
	 * Sets the current value of \f$\alpha\f$ to 4.
	 * @param de
	 */
	public void setAlpha(DEKernelDensity de) {
		setAlpha(4.0);
	}
	/**
	 * If \a de is neither a histogram or a KDE, nor has a separate method for the type of \a de has been implemented,
	 * this method will throw an exception.
	 * @param de
	 */
	public void setAlpha(DensityEstimator de) {
		throw new UnsupportedOperationException (
		         "setAlpha is not implemented for DesityEstimator " + de.toString() + ". Either implement this"
		         		+ " method or use setAlpha(double)");
	}

	/**
	 * Gives the current value of \f$B\f$.
	 * 
	 * @return \f$B\f$.
	 */
	public double getB() {
		return B;
	}

	/**
	 * Sets the current value of \f$B\f$ to \a B.
	 * 
	 * @param B
	 *            the desired value for \f$B\f$.
	 */
	public void setB(double B) {
		this.B = B;
	}

	/**
	 * Sets the current value of \f$\beta\f$ to \a beta.
	 * 
	 * @param beta
	 *            the desired value for \f$\beta\f$.
	 */
	public void setBeta(double beta) {
		this.beta = beta;
	}

	/**
	 * Gives the current value of \f$\beta\f$.
	 * 
	 * @return \f$\beta\f$.
	 */
	public double getBeta() {
		return beta;
	}

	/**
	 * Sets the current value of \f$C\f$ to \a C.
	 * 
	 * @param C
	 *            the desired value for \f$C\f$.
	 */
	public void setC(double C) {
		this.C = C;
	}

	/**
	 * Gives the current value of \f$C\f$.
	 * 
	 * @return \f$C\f$.
	 */
	public double getC() {
		return C;
	}

	/**
	 * Gives the current value of \f$\delta\f$.
	 * 
	 * @return \f$\delta\f$.
	 */
	public double getDelta() {
		return delta;
	}

	/**
	 * Sets the current value of \f$\delta\f$ to \a delta.
	 * 
	 * @param delta
	 *            the desired value for \f$\delta\f$.
	 */
	public void setDelta(double delta) {
		this.delta = delta;
	}

	
	public double estimateLogIV(double logH, double logN) {
		return (Math.log(getC()) / Math.log(baseOfLog) - getBeta() * logN - getDelta() * logH);
	}

	public double estimateLogISB(double logH) {
		return (Math.log(getB()) / Math.log(baseOfLog) + getAlpha() * logH);
	}

	public double estimateLogMISE(double logN) {
		return (Math.log(getK()) / Math.log(baseOfLog) - getNu() * logN);
	}

	public static void setH(DEHistogram de, double h) {
		de.setH(h);
	}
	
	public static void setH(DEKernelDensity de, double h) {
		de.setH(h);
	}
	
	public static void setH(DensityEstimator de, double h) {
		throw new UnsupportedOperationException (
		         "setH is not implemented for the DensityEstimator " + de.toString());
	}
	/**
	 * Gives #logH, the logs of the bin-/bandwidths in the test grid for
	 * \f$(n,h)\f$.
	 * 
	 * @return the logs of the bin-/bandwidths considered.
	 */
	public double[] getLogH() {
		return logH;
	}
	
	public double getNu() {
		return getAlpha() * getGamma();
	}

	public double getKappa() {
		return Math.pow(getC() * getDelta() / (getB() * getAlpha()), 1.0 / (getAlpha() + getDelta()));
	}

	public double getGamma() {
		return getBeta() / (getAlpha() + getDelta());
	}

	public double getK() {
		double kappa = getKappa();
		return getC() * Math.pow(kappa, -getDelta()) + getB() * Math.pow(kappa, getAlpha());
	}

	/**
	 * Gives #logN, the logs of the numbers of observations considered in the test
	 * grid for \f$(n,h)\f$.
	 * 
	 * @return the logs of the numbers of observations consider
	 */
	public double[] getLogN() {
		return logN;
	}

	/**
	 * Sets #logH, the logs of the bin-/bandwidths based, to \a hArray.
	 * 
	 * @param hArray
	 *            an array containing the desired bin-/bandwidths.
	 */
	public void setLogH(double[] hArray) {
		logH = new double[hArray.length];
		for (int i = 0; i < hArray.length; i++)
			logH[i] = Math.log(hArray[i]) / Math.log(baseOfLog);
	}

	/**
	 * Sets #logN, the logs of the numbers of observations, to \a N.
	 * 
	 * @param N
	 */
	public void setLogN(int[] N) {
		logN = new double[N.length];
		for (int i = 0; i < N.length; i++)
			logN[i] = Math.log(N[i]) / Math.log(baseOfLog);
	}

	/**
	 * For parameter estimation of the IV this method produces a formatted string
	 * carrying basic information that can be used as a introductory head for the
	 * estimation of the IV parameters.
	 *
	 * @param pointLabel
	 *            a description of the point set employed.
	 * @param estimatorLabel
	 *            a description of the density estimator.
	 * @param numEvalPoints
	 *            the number of evaluation points to estimate the empirical IV
	 * @param m
	 *            the number of independent replications of the observations.
	 * @return a formatted introductory head for the parameter estimation of the IV.
	 */
	public String parametersIVFormatHead(String pointLabel, String estimatorLabel, String numEvalPoints, int m) {
		StringBuffer sb = new StringBuffer("");
		sb.append("Model parameter estimation for the IV over the interval [" + a + ", " + b + "]\n");
		sb.append("----------------------------------------------------------------\n\n");
		sb.append("Estimator: " + estimatorLabel + "\n");
		sb.append("Point set used: " + pointLabel + "\n");
		sb.append("Number of repititions: m = " + m + "\n");
		sb.append("Evaluation points: " + numEvalPoints + "\n");
		sb.append("----------------------------------------------------------------\n\n");
		if(displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}

	public String parametersIVFormatHead(String pointLabel, String estimatorLabel, int m) {
		return parametersIVFormatHead(pointLabel,estimatorLabel,"variable",m);
	}

	/**
	 * Routine to initialize #logN, #logH, and #logIV3D for the estimation of the IV
	 * parameters. The array \a rqmcPts is used to determine the numbers of
	 * observations.
	 * 
	 * @param rqmcPts
	 *            the RQMC point set for different numbers of observations used for
	 * @param hArray
	 *            the bin-/bandwidths from the testing grid for \f$(n,h)\f$.
	 */
	public void parametersIVPreprocess(RQMCPointSet[] rqmcPts, double[] hArray) {
		logIV3D = new double[rqmcPts.length * hArray.length];
		setLogH(hArray);
		logN = new double[rqmcPts.length];
		for (int i = 0; i < rqmcPts.length; i++)
			logN[i] = Math.log((double) rqmcPts[i].getNumPoints()) / Math.log(baseOfLog);
	}

	public String parametersIVComputeRegData(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DensityEstimator de, double[] hArray, double[][] regDataX, double[] evalPoints) {
		double[] variance;
		double[][] data;
		double[][] density;
		Tally statReps = new Tally();
		String str;
		StringBuffer sb = new StringBuffer("");
		
		str = "log(n)\t\t log(h)\t\t empirical IV \n\n";
		
		sb.append(str);
		if (displayExec)
			System.out.print(str);

		for (int i = 0; i < logN.length; i++) { // point sets indexed by i
			for (int j = 0; j < logH.length; j++) { // h's indexed by j
				data = new double[m][];

				RQMCExperiment.simulReplicatesRQMC(model, rqmcPts[i], m, statReps, data);
				setH(de, hArray[j]);
				density = new double[m][evalPoints.length];
				density = de.evalDensity(evalPoints, data, a, b);

				variance = new double[evalPoints.length];

				regDataX[i * logH.length + j] = new double[2];
				regDataX[i * logH.length + j][0] = logN[i];
				regDataX[i * logH.length + j][1] = logH[j];

				logIV3D[i * logH.length + j] = Math.log(DensityEstimator.computeIV(density, a, b, variance))
						/ Math.log(baseOfLog);

				str = PrintfFormat.f(3, 1, logN[i]) + "\t " + PrintfFormat.f(6, 4, logH[j]) + "\t "
						+ logIV3D[i * logH.length + j] + "\n";
				sb.append(str);
				if (displayExec)
					System.out.print(str);
			}
			
		}
		
		str = "\n\n";
		sb.append(str);
		if (displayExec)
			System.out.print(str);
		
		return sb.toString();
	}
	
	public String parametersIVComputeRegData(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de, double[] hArray, double[][] regDataX) {
		double[] variance;
		double[][] data;
		double[][] density;
		Tally statReps = new Tally();
		String str;
		StringBuffer sb = new StringBuffer("");
		
		str = "log(n)\t\t log(h)\t\t empirical IV \n\n";
		
		sb.append(str);
		if (displayExec)
			System.out.print(str);

		for (int i = 0; i < logN.length; i++) { // point sets indexed by i
			for (int j = 0; j < logH.length; j++) { // h's indexed by j
				data = new double[m][];

				RQMCExperiment.simulReplicatesRQMC(model, rqmcPts[i], m, statReps, data);
				de.setH(hArray[j]);
				density = new double[m][de.getNumBins()];
				density = de.evalDensity(data, a, b);

				variance = new double[de.getNumBins()];

				regDataX[i * logH.length + j] = new double[2];
				regDataX[i * logH.length + j][0] = logN[i];
				regDataX[i * logH.length + j][1] = logH[j];

				logIV3D[i * logH.length + j] = Math.log(DensityEstimator.computeIV(density, a, b, variance))
						/ Math.log(baseOfLog);

				str = PrintfFormat.f(3, 1, logN[i]) + "\t " + PrintfFormat.f(6, 4, logH[j]) + "\t "
						+ logIV3D[i * logH.length + j] + "\n";
				sb.append(str);
				if (displayExec)
					System.out.print(str);
			}
			
		}
		
		str = "\n\n";
		sb.append(str);
		if (displayExec)
			System.out.print(str);
		
		return sb.toString();
	}
	
	public String parametersIVComputeRegData(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de, double[] hArray, double[][] regDataX, double[] evalPoints) {
		return parametersIVComputeRegData(model, rqmcPts, m, de, hArray, regDataX);
	}
	
	
	
	/**
	 * Takes the testing region for \f$(n,h)\f$ in \a regDataX and performs a linear
	 * regression with the data saved in #logIV3D. Subsequently, it will set the
	 * parameters \f$C\f$, \f$\beta\f$, and \f$delta\f$ to the values obtained.
	 * 
	 * @param regDataX
	 */
	public void parametersIVComputeCoefficients(double[][] regDataX) {
		double[] regCoeffs = LeastSquares.calcCoefficients0(regDataX, logIV3D);
		setC(Math.pow(baseOfLog, regCoeffs[0]));
		setBeta(-regCoeffs[1]);
		setDelta(-regCoeffs[2]);
	}

	/**
	 * Gives the current values of the parameters \f$C\f$, \f$\beta\f$, and
	 * \f$delta\f$ as formatted string.
	 * 
	 * @return the IV parameters in a formatted string.
	 */
	public String parametersIVFormatCoefficients() {

		String str = "Estimated IV-parameters:\n";
		str += "-------------------------------------";
		str += "C =\t" + getC() + "\n";
		str += "beta =\t" + getBeta() + "\n";
		str += "delta =\t" + getDelta() + "\n\n";
		
		if(displayExec)
			System.out.print(str);

		return str;
	}

	/**
	 * This method is the core function for estimating the IV parameters \f$C\f$,
	 * \f$\beta\f$, and \f$delta\f$ for a histogram estimator by estimating the
	 * empirical IV over a testing region for \f$(n,h)\f$ and, subsequently,
	 * performing a linear regression.
	 * 
	 * More precisely, \a rqmcPts is intended to contain the same type of point set
	 * in different sizes \f$n\f$. These sizes are the \f$n\f$-values for the
	 * testing region. The \f$h\f$-values are passed in \a hArray. For every point
	 * in \a rqmcPts it generates observations of \a model. This is repeated \f$m\f$
	 * times independently. On the basis of these observations it estimates the
	 * empirical IV for every \f$h\f$ in \a hArray. The evaluation points used in
	 * this step are the number of bins currently set for the histogram, as this is
	 * sufficient. The estimated IVs are stored in #logIV3D. Finally, this data is
	 * used to estimate the parameters by a linear regression.
	 * 
	 * The string which is returned is composed of an introductory heading, a table
	 * showing the results of the estimates of the empirical IV for different
	 * \f$n\f$ and \f$h\f$, and a formatted output of the estimated parameters
	 * \f$C\f$, \f$\beta\f$, and \f$delta\f$ so that the details of this experiment
	 * can be written to a file. If the user wishes to display output at runtime as
	 * well, simply set #displayExec to <tt>true<\tt>.
	 * 
	 * 
	 * @param rqmcPts
	 *            the RQMC point sets to construct the observation.
	 * @param model
	 *            the underlying model, from which the observations are obtained.
	 * @param m
	 *            the number of independent repetitions.
	 * @param de
	 *            the histogram.
	 * @param hArray
	 *            the values for \f$h\f$ of the testing region.
	 * @return a formatted String containing all the information about this
	 *         parameter estimation.
	 */
	public String parametersIVEstimate(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de,
			double[] hArray) {
		StringBuffer sb = new StringBuffer("");

		parametersIVPreprocess(rqmcPts, hArray);

		
		double[][] regDataX = new double[logIV3D.length][];
		
		sb.append( parametersIVFormatHead(rqmcPts[0].getLabel(), de.toString(),m) );
		
		sb.append(parametersIVComputeRegData(model,rqmcPts,m,de,hArray,regDataX));

		parametersIVComputeCoefficients(regDataX);

		sb.append(parametersIVFormatCoefficients());
	
		return sb.toString();
	}
	
	
	

	/**
	 * Same as #parametersIVEstimate(RQMCPointSet[], MonteCarloModelDouble, int,
	 * DEHistogram, double[]) for KDEs. A slight difference is that, here, we need
	 * to pass the evaluation points to compute the IV.
	 * 
	 * @param rqmcPts
	 *            the RQMC point sets to construct the observation.
	 * @param model
	 *            the underlying model, from which the observations are obtained.
	 * @param m
	 *            the number of independent repetitions.
	 * @param de
	 *            the histogram.
	 * @param hArray
	 *            the values for \f$h\f$ of the testing region.
	 * @param evalPoints
	 *            the evaluation points used to estimate the empirical IV.
	 * @return a formatted String containing all the information about this
	 *         parameter estimation.
	 */
	public String parametersIVEstimate( MonteCarloModelDouble model,RQMCPointSet[] rqmcPts, int m, DensityEstimator de,
			double[] hArray, double[] evalPoints) {

		StringBuffer sb = new StringBuffer("");

		parametersIVPreprocess(rqmcPts, hArray);

		
		double[][] regDataX = new double[logIV3D.length][];
		
		sb.append( parametersIVFormatHead(rqmcPts[0].getLabel(), de.toString(),Integer.toString(evalPoints.length),m) );
		
		sb.append(parametersIVComputeRegData(model, rqmcPts,  m,  de,  hArray,  regDataX,  evalPoints));

		parametersIVComputeCoefficients(regDataX);

		sb.append(parametersIVFormatCoefficients());
	
		return sb.toString();

	}

	public void estimateB(MonteCarloModelDouble model, RQMCPointSet rqmc,  int m, double[] evalPoints, int order,
			double factor) {
		double[][] data = new double[m][];
		Tally statReps = new Tally();
		RQMCExperiment.simulReplicatesRQMC(model, rqmc, m, statReps, data);
		int n = rqmc.getNumPoints();

		DEDerivativeGaussian dde = new DEDerivativeGaussian(order);
		double[] muSigma = new double[2];
		double init;
		double h;
		double mu2Derivative = DensityDerivativeEstimator.densityFunctionalGaussian(order, 1.0);
		double[] density = new double[evalPoints.length];
		double rf = 0.0;

		for (int rep = 0; rep < m; rep++) {
			muSigma = DensityEstimator.estimateMeanAndStdDeviation(data[rep]);
			init = setInitRoughnessFunctional(order + 2, muSigma[0], muSigma[1]);
			h = DEDerivativeGaussian.hAmiseR(order, 1.0, mu2Derivative, init, n);
			dde.setH(h);
			density = dde.evalDensity(evalPoints, data[rep], a, b);
			rf += DensityEstimator.roughnessFunctional(density, a, b);
		}

		rf /= (double) m;
		setB(factor * rf);
	}
	
	public double setInitRoughnessFunctional(int order, double mu, double sigma) {
		double result = 0.0;
		double sqrtPi = Math.sqrt(Math.PI);
		double aTerm = (mu - a) / sigma;
		double bTerm = (b - mu) / sigma;
		double pdfA = NormalDist.density(mu, sigma, a);
		double pdfB = NormalDist.density(mu, sigma, b);

		if (order == 4) {
			result = pdfA * pdfA * aTerm * (8.0 * Math.pow(aTerm, 6.0) - 68.0 * aTerm * aTerm * aTerm * aTerm
					+ 166.0 * aTerm * aTerm - 39.0);
			result += pdfB * pdfB * bTerm * (8.0 * Math.pow(bTerm, 6.0) - 68.0 * bTerm * bTerm * bTerm * bTerm
					+ 166.0 * bTerm * bTerm - 39.0);
			result *= -2.0 * sqrtPi * sigma * sigma;

			result += 105.0 * (NormalDist.cdf(mu, sigma, Math.sqrt(2.0) * (b - mu) + mu)
					- NormalDist.cdf(mu, sigma, Math.sqrt(2.0) * (a - mu) + mu));
			return result / (32.0 * sqrtPi * Math.pow(sigma, 9.0));
		}

		else if (order == 3) {

			result = pdfA * pdfA * aTerm * (4.0 * aTerm * aTerm * aTerm * aTerm - 14.0 * aTerm * aTerm + 15.0);
			result += pdfB * pdfB * bTerm * (4.0 * bTerm * bTerm * bTerm * bTerm - 14.0 * bTerm * bTerm + 15.0);
			result *= -2.0 * sqrtPi * sigma * sigma;

			result += 15.0 * (NormalDist.cdf(mu, sigma, Math.sqrt(2.0) * (b - mu) + mu)
					- NormalDist.cdf(mu, sigma, Math.sqrt(2.0) * (a - mu) + mu));
			return result / (16.0 * sqrtPi * Math.pow(sigma, 7.0));
		}

		else {
			throw new UnsupportedOperationException (
			         "setInitRoughnessFunctional is not implemented for the order " + order);
		}
	}
	
	public String parametersISBFormatHead(String pointLabel, String estimatorLabel, int numEvalPoints, int m, int n) {
		StringBuffer sb = new StringBuffer("");
		sb.append("Model parameter estimation for the ISB over the interval [" + a + ", " + b + "]\n");
		sb.append("----------------------------------------------------------------\n\n");
		sb.append("Estimator: " + estimatorLabel + "\n");
		sb.append("Point set used: " + pointLabel + "\n");
		sb.append("Number of points: " + n + "\n");
		sb.append("Number of repititions: m = " + m + "\n");
		sb.append("Evaluation points: " + numEvalPoints + "\n");
		sb.append("----------------------------------------------------------------\n\n");
		if(displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}

	public String parametersISBFormatCoefficients() {
		String str = "ISB-parameters:\n";
		str += "-------------------------------------\n";
		str += "alpha =\t" + getAlpha() + "\n";
		str += "B =\t" + getB() + "\n\n";
		if(displayExec)
			System.out.print(str);
		return str;
	}


	public String parametersISBEstimate( MonteCarloModelDouble model, RQMCPointSet rqmc, int m, DEKernelDensity de,
			double[] evalPoints) {
		StringBuffer sb = new StringBuffer("");

		
		sb.append(parametersISBFormatHead(rqmc.getLabel(), "Kernel density estimator", evalPoints.length, m,
				rqmc.getNumPoints()));
		
		int order = 2;
		double factor = 0.25;

		estimateB( model,rqmc, m, evalPoints, order, factor);

		sb.append( parametersISBFormatCoefficients());

		return sb.toString();
	}

	public String parametersISBEstimate(MonteCarloModelDouble model, RQMCPointSet rqmc, int m, DEHistogram de,
			double[] evalPoints) {
		StringBuffer sb = new StringBuffer("");
		
		sb.append(parametersISBFormatHead(rqmc.getLabel(), "Histogram", evalPoints.length, m,
				rqmc.getNumPoints()));
		
		int order = 1;
		double factor = 1.0 / 12.0;
		
		estimateB( model, rqmc, m, evalPoints, order, factor);
		
		sb.append( parametersISBFormatCoefficients());
		
		return sb.toString();
	}

	public String parametersISBEstimate(MonteCarloModelDouble model, RQMCPointSet rqmc, int m, DensityEstimator de,
			double[] evalPoints) {
		throw new UnsupportedOperationException (
		         "parametersISBEstimate is not implemented for the DensityEstimator " + de.toString());		
	}
	
	
	

	public String parametersMISEFormatCoefficients() {
		StringBuffer sb = new StringBuffer("");
		sb.append("MISE-parameters: \n");
		sb.append("-------------------------------------\n");
		sb.append("gamma =\t" + getGamma() + "\n");
		sb.append("kappa =\t" + getKappa() + "\n");
		sb.append("K =\t" + getK() + "\n");
		sb.append("nu =\t" + getNu() + "\n\n");
		if(displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}

	

	/**
	 * For parameter estimation of the IV this method produces a formatted string
	 * carrying basic information that can be used as a introductory head for the
	 * estimation of the IV parameters.
	 *
	 * @param pointLabel
	 *            a description of the point set employed.
	 * @param estimatorLabel
	 *            a description of the density estimator.
	 * @param numEvalPoints
	 *            the number of evaluation points to estimate the empirical IV
	 * @param m
	 *            the number of independent replications of the observations.
	 * @return a formatted introductory head for the parameter estimation of the IV.
	 */
	public String estimateMISEOptHFormatHead(String pointLabel, String estimatorLabel, String numEvalPoints,
			int m) {
		StringBuffer sb = new StringBuffer("");
		sb.append("Estimation of MISE rate with optimal h over [" + a + ", " + b + "]\n");
		sb.append("----------------------------------------------------------------\n\n");
		sb.append("Estimator: " + estimatorLabel + "\n");
		sb.append("Point set used: " + pointLabel + "\n");
		sb.append("Number of repititions: m = " + m + "\n");
		sb.append("Evaluation points: " + numEvalPoints + "\n");
		sb.append("----------------------------------------------------------------\n\n");
		if(displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}
	
	public String estimateMISEOptHFormatHead(String pointLabel, String estimatorLabel,
			int m) {
		return estimateMISEOptHFormatHead(pointLabel, estimatorLabel,"variable",m);
	}

	public void estimateMISEOptHPreprocess(RQMCPointSet[] rqmcPts) {
		logN = new double[rqmcPts.length];
		logH = new double[logN.length];
		for (int i = 0; i < rqmcPts.length; i++) {
			logN[i] = Math.log((double) rqmcPts[i].getNumPoints()) / Math.log(baseOfLog);
			logH[i] = Math.log(getKappa()) / Math.log(baseOfLog) - getGamma() * logN[i];
		}
		logEstIV = new double[logN.length];
		logEstISB = new double[logN.length];
		logEstMISE = new double[logN.length];
		for (int i = 0; i < logN.length; i++) {
			logEstIV[i] = estimateLogIV(logH[i], logN[i]);
			logEstISB[i] = estimateLogISB(logH[i]);
			logEstMISE[i] = estimateLogMISE(logN[i]);
		}

		logIV = new double[logN.length];
		logMISE = new double[logN.length];
	}

	public String estimateMISEOptHComputeTable( MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de) {
		
		StringBuffer sb = new StringBuffer("");
		String str;
		
		str = "log(n)\t log(h*)\t estimated log(IV)\t estimated log(ISB)\t estimated log(MISE) \t empirical log(IV) \t empirical log(MISE)\n\n";

		sb.append(str);
		if (displayExec)
			System.out.print(str);

		Tally statReps = new Tally();
		double[][] data = new double[m][];
		double[][] density;
		double[] variance;
		
		for (int i = 0; i < rqmcPts.length; i++) {// rqmc point sets indexed by i
			
			RQMCExperiment.simulReplicatesRQMC(model, rqmcPts[i], m, statReps, data);
			de.setH(Math.pow(baseOfLog, logH[i]));
			density = new double[m][de.getNumBins()];
			density = de.evalDensity(data, a, b);
			
			variance = new double[de.getNumBins()];

			logIV[i] = DensityEstimator.computeIV(density, a, b, variance);
			logMISE[i] = logIV[i] + logEstISB[i];
			
			str = PrintfFormat.f(3, 1, logN[i]) + "\t " + PrintfFormat.f(8, 6, logH[i]) + "\t "
					+ PrintfFormat.f(8, 6, logEstIV[i]) + "\t " + PrintfFormat.f(8, 6, logEstISB[i]) + "\t "
					+ PrintfFormat.f(8, 6, logEstMISE[i]) + "\t " + PrintfFormat.f(8, 6, logIV[i]) + "\t "
					+ PrintfFormat.f(8, 6, logMISE[i]) + "\n ";
			
			
			sb.append(str);
			if (displayExec)
				System.out.print(str);

		
		}
		
		str = "\n\n";
		sb.append(str);
		if (displayExec)
			System.out.print(str);

		return sb.toString();

	}
	
	public String estimateMISEOptHComputeTable( MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DensityEstimator de,
			double[] evalPoints) {
		
		StringBuffer sb = new StringBuffer("");
		String str;
		
		str = "log(n)\t log(h*)\t estimated log(IV)\t estimated log(ISB)\t estimated log(MISE) \t empirical log(IV) \t empirical log(MISE)\n\n";

		sb.append(str);
		if (displayExec)
			System.out.print(str);

		Tally statReps = new Tally();
		double[][] data = new double[m][];
		double[][] density;
		double[] variance;
		
		for (int i = 0; i < rqmcPts.length; i++) {// rqmc point sets indexed by i
			
			RQMCExperiment.simulReplicatesRQMC(model, rqmcPts[i], m, statReps, data);
			setH(de,Math.pow(baseOfLog, logH[i]));
			density = new double[m][evalPoints.length];
			density = de.evalDensity(evalPoints,data, a, b);
			
			variance = new double[evalPoints.length];

			logIV[i] = DensityEstimator.computeIV(density, a, b, variance);
			logMISE[i] = logIV[i] + logEstISB[i];
			
			str = PrintfFormat.f(3, 1, logN[i]) + "\t " + PrintfFormat.f(8, 6, logH[i]) + "\t "
					+ PrintfFormat.f(8, 6, logEstIV[i]) + "\t " + PrintfFormat.f(8, 6, logEstISB[i]) + "\t "
					+ PrintfFormat.f(8, 6, logEstMISE[i]) + "\t " + PrintfFormat.f(8, 6, logIV[i]) + "\t "
					+ PrintfFormat.f(8, 6, logMISE[i]) + "\n ";
			
			
			sb.append(str);
			if (displayExec)
				System.out.print(str);

		
		}
		
		str = "\n\n";
		sb.append(str);
		if (displayExec)
			System.out.print(str);

		return sb.toString();

	}

	public String estimateMISEOptHRsqIV() {
		String str = "Coefficient of determination:\n";
		str += "********************************************\n\n";
		str += "R^2 for IV: " + DensityEstimator.coefficientOfDetermination(logIV, logEstIV) + "\n\n";
		if(displayExec)
			System.out.print(str);
		return str;
	}

	public String estimateMISEOptHSlopes() {
		double[] regCoeffs = new double[2];

		String str = "Regression data:\n";
		str += "********************************************\n\n";
		str += "IV:\n";

		regCoeffs = LeastSquares.calcCoefficients(logN, logIV);
		str += "Slope:\t" + regCoeffs[1] + "\n";
		str += "Const.:\t" + regCoeffs[0] + "\n\n";
		str += "MISE:\n";
		regCoeffs = LeastSquares.calcCoefficients(logN, logMISE);
		str += "Slope:\t" + regCoeffs[1] + "\n";
		str += "Const.:\t" + regCoeffs[0] + "\n\n";

		if(displayExec)
			System.out.print(str);
		return str;
	}

	public String estimateMISEOptH(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de) {
		StringBuffer sb = new StringBuffer("");
		sb.append( estimateMISEOptHFormatHead(rqmcPts[0].getLabel(), "Histogram", m));
		estimateMISEOptHPreprocess(rqmcPts);
		sb.append( estimateMISEOptHComputeTable(model,rqmcPts,m,de));
		sb.append(estimateMISEOptHRsqIV());
		sb.append(estimateMISEOptHSlopes());

		return sb.toString();
	}
	
	public String estimateMISEOptH(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de,double[] evalPoints) {
		return estimateMISEOptH(model,rqmcPts,m,de);
	}
	
	public String estimateMISEOptH(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DensityEstimator de, double[] evalPoints) {
		StringBuffer sb = new StringBuffer("");
		sb.append( estimateMISEOptHFormatHead(rqmcPts[0].getLabel(), de.toString(), Integer.toString(evalPoints.length), m));
		estimateMISEOptHPreprocess(rqmcPts);
		sb.append( estimateMISEOptHComputeTable(model,rqmcPts,m,de,evalPoints));
		sb.append(estimateMISEOptHRsqIV());
		sb.append(estimateMISEOptHSlopes());

		return sb.toString();
	}

	public String testMISERateFormatHead(MonteCarloModelDouble model) {
		StringBuffer sb = new StringBuffer("");
		sb.append("DENSITY ESTIMATION\n");
		sb.append("************************************************\n");
		sb.append("Density estimation with the bandwidth-based parametric model for\n");
		sb.append(model.toString());
		sb.append("----------------------------------------------------------------\n\n");
		if(displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}
	public String testMISERate(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DensityEstimator de, double [] hArray, double[] evalPoints) {
		StringBuffer sb = new StringBuffer("");
		sb.append(testMISERateFormatHead(model));
		
		sb.append(parametersIVEstimate( model, rqmcPts,  m,  de, hArray,  evalPoints));
		sb.append(parametersISBEstimate( model,  rqmcPts[rqmcPts.length-1], m, de,
			 evalPoints));
		sb.append(parametersMISEFormatCoefficients());
		sb.append(estimateMISEOptH( model, rqmcPts,  m,  de, evalPoints));
				
		return sb.toString();
	}
	
	public String testMISERate(MonteCarloModelDouble model, ArrayList<RQMCPointSet[]> rqmcPtsList, int m, DensityEstimator de, double[] hArray, double[] evalPoints) {
		StringBuffer sb = new StringBuffer("");
		for(RQMCPointSet [] rqmcPts : rqmcPtsList)
			sb.append(testMISERate(model,rqmcPts,m,de,hArray,evalPoints));
		
		return sb.toString();
	}
	
	public String testMISERate(MonteCarloModelDouble model, ArrayList<RQMCPointSet[]> rqmcPtsList, int m, ArrayList<DensityEstimator> deList, double[] hArray, double[] evalPoints) {
		StringBuffer sb = new StringBuffer("");
		for(DensityEstimator de : deList)
			sb.append(testMISERate(model,rqmcPtsList,m,de,hArray,evalPoints));
		return sb.toString();
	}
	
	public String testMISERate(MonteCarloModelDouble model, ArrayList<RQMCPointSet[]> rqmcPtsList, int m, ArrayList<DensityEstimator> deList, ArrayList<double[]> hArrayList, double[] evalPoints) {
		StringBuffer sb = new StringBuffer("");
		int len = deList.size();
		for(int l = 0; l < len; l++)
			sb.append(testMISERate(model,rqmcPtsList,m,deList.get(l),hArrayList.get(l),evalPoints));
		return sb.toString();
	}

}
