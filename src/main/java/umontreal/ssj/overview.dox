/**
 * @mainpage SSJ User's Guide.
 * 
 * 
 ********************************************************************** 
 * @section REF_0_sec_01 Introduction and overview
 * 
 * SSJ (Stochastic Simulation in Java) is a Java library offering tools
 * for stochastic (Monte Carlo) simulation @cite sASM07a, @cite sLAW14a.
 * It provides basic facilities for random number generation with multiple
 * streams and substreams, implements univariate and multivariate probability
 * distributions and variate generators for them, functions to simulate certain types 
 * of stochastic processes, efficient event-list management tools for 
 * discrete-event simulation, support for an extensive collection of randomized
 * quasi-Monte Carlo methods, statistical collectors to collect data in simulation
 * experiments, statistical estimation and goodness-of-fit methods, 
 * some tools to produce plots in LaTeX, and various other classes and methods 
 * that can be useful for simulation.
 * 
 * These tools are organized in a powerful and very flexible system (or framework)
 * of packages and classes.
 * SSJ can be used to write simulation programs for stochastic models of various types
 * of real-life systems, simple or very complex.  
 * It is also appropriate for implementing Monte Carlo methods in various areas
 * of applications.
 * 
 * For discrete-event simulation, commercial tools with
 * drag-and-drop graphical interfaces such as *AnyLogic*, *Arena*, *Automod*,
 * *ProModel*, *Simio*, *Simul8*, *Witness*, and many others, are very widely used.
 * Among their main advantages, these tools do
 * not require knowledge of a programming language, provide graphical
 * animation, have automatic facilities to collect statistics and perform
 * experiments, and can sometimes perform optimization to a certain extent.
 * On the other hand, they are often too restrictive, because they are
 * targeted at specific classes of models. With these tools, simulating a
 * system whose logic is complicated or unconventional may become
 * difficult. The graphical and automatic devices also tend to slow down
 * the simulation significantly.  Fast execution times are important for
 * example in a context of optimization, where thousands of variants of a
 * base system may have to be simulated, or for on-line applications where a
 * fast response time is required.
 *
 * SSJ, on the other hand, is very flexible and designed to facilitate efficient
 * simulation programming in the Java language. A first version was described 
 * in @cite sLEC02a&thinsp;.  Some of the tools can also be used for modeling
 * (e.g., selecting and fitting distributions).  
 *
 * The facilities offered are grouped into different well-documented packages
 * that are connected to each other.  In addition to the online documentation 
 * (produced by Doxygen), there is a reference manual in the form of a .pdf file. 
 * There is also a tutorial guide that contains a set of commented examples of 
 * simulation programs, together with the Java code.
 * Some of these examples are taken from books such as @cite sLAW14a, 
 * and @cite fGLA04a, for example. The best way to start learning SSJ is to study 
 * these examples and refer to the reference manual or the online documentation when needed. 
 *
 *
 * The packages currently offered are the following:
 * 
 * ## Probability distributions, random number and random variate generation, and quasi-Monte Carlo.
 * 
 *  @ref umontreal.ssj.probdist 
 *  contains a set of Java classes providing
 * methods to compute mass, density, distribution, complementary
 * distribution, and inverse distribution functions for many discrete and
 * continuous probability distributions, as well as estimating the parameters
 * of these distributions.
 *
 *  @ref umontreal.ssj.probdistmulti 
 *  contains a set of Java classes providing
 * methods to compute mass, density, distribution, complementary
 * distribution, for some multi-dimensionnal discrete and continuous
 * probability distributions.
 *
 *  @ref umontreal.ssj.rng 
 *  provides facilities for generating uniform random
 * numbers over the interval @f$(0,1)@f$, or over a given range of integer
 * values, and other types of simple random objects such as random
 * permutations.  The basic type of object here is a *stream* of random numbers.
 *
 *  @ref umontreal.ssj.latnetbuilder
 *  is essentially an interface to the LatNet Builder software
 *  to constructs quasi-Monte Carlo point sets and sequences of various types
 *  (lattices, polynomial lattices, digital nets, etc.) for arbitrary dimension
 *  and cardinality, various uniformity criteria, etc.
 *   
 *  @ref umontreal.ssj.hups 
 *  provides classes implementing highly uniform
 * point sets and sequences (HUPS), also called low-discrepancy sets and
 * sequences, used for quasi-Monte Carlo methods, and tools for their randomization
 * (for randomized quasi-Monte Carlo).  
 *
 *  @ref umontreal.ssj.randvar 
 *  provides a collection of classes for
 * non-uniform random variate generation, primarily from standard
 * distributions.
 *
 *  @ref umontreal.ssj.randvarmulti 
 *  provides a collection of classes for
 *  random number generators for some multi-dimensional distributions.
 *
 *  @ref umontreal.ssj.stochprocess implements different kinds of stochastic
 * processes.
 * 
 *
 * ## Statistical tools
 *
 *  @ref umontreal.ssj.stat provides elementary tools for collecting
 * statistics and computing confidence intervals.
 *
 *  @ref umontreal.ssj.stat.matrix this subpackage of `stat` provides
 * facilities to create and manage rectangular two-dimensional arrays of
 * statistical collectors.
 *
 *  @ref umontreal.ssj.stat.list 
 *  this subpackage of `stat` provides support
 * to manage lists of statistical collectors.
 *
 *  @ref umontreal.ssj.stat.list.lincv 
 *  this subpackage of `stat.list`
 * provides classes that help implement control variables on lists of
 * collectors.
 *
 *  @ref umontreal.ssj.gof 
 * contains tools for performing univariate
 * goodness-of-fit (GOF) statistical tests.
 *
 *  @ref umontreal.ssj.density 
 *  offers tools to construct histograms and estimate densities from data.
 *
 *
 * ## Discrete-event simulation
 *
 *  @ref umontreal.ssj.simevents provides and manages the event-driven
 * simulation facilities as well as the simulation clock. Can manage several
 * simulations in parallel, in the same program.
 *
 *  @ref umontreal.ssj.simevents.eventlist this subpackage of `simevents`
 * offers several kinds of event list implementations.
 *
 *  @ref umontreal.ssj.functions 
 *  contains classes that allow one to pass an
 * arbitrary function of one variable as argument to a method and to apply
 * elementary mathematical operations on generic functions.
 *
 *  @ref umontreal.ssj.functionfit 
 *  provides basic facilities for curve
 * fitting and interpolation with polynomials.
 *
 *
 * ## Simulation experiments with MC and RQMC
 * 
 *
 *  @ref umontreal.ssj.charts 
 *  provides tools for easy construction,
 * visualization, and customization of @f$xy@f$ plots, histograms, and
 * empirical styled charts from a Java program.
 *
 *  @ref umontreal.ssj.simexp 
 *  provides facilities for performing simulation
 * experiments using independent replications as well as simulations using
 * batch means.
 *
 *  @ref umontreal.ssj.mcqmctools
 * offers some predefined methods to perform Monte Carlo and 
 *  (randomized) quasi-Monte Carlo experiments.
 *
 *  @ref umontreal.ssj.mcqmctools.anova
 * provides methods to estimate ANOVA components for Monte Carlo models.
 *
 *  @ref umontreal.ssj.markovchainrqmc 
 * contains classes designed for Markov chain simulation using 
 * randomized quasi-Monte Carlo, e.g., via Array-RQMC.
 *
 * 
 *  * ## Basic utilities:
 *
 *  @ref umontreal.ssj.util 
 *  contains basic utility classes used in the
 * implementation of SSJ, and which can be useful elsewhere. For example,
 * there are timers (for CPU usage), utilities to read or format numbers and
 * arrays from/to text, operations on binary vectors and matrices, some
 * mathematical functions and constants, root-finding tools, and so on.
 *
 *  @ref umontreal.ssj.util.sort 
 * contains utility classes to sort multi-dimensional points.
 * This is useful for Array-RQMC, for example.
 *
 *  @ref umontreal.ssj.functions
 * implements certain functions that can be passed as objects.
 *
 *  @ref umontreal.ssj.functionfit
 * implements some elementary function approximation methods such as polynomial 
 * interpolation, splines, linear regression, etc.
 *
 *
 *
 ********************************************************************** 
 * @section REF_0_sec_02 Dependence on other libraries
 * 
 * 
 * The following free third-party Java libraries are used in the implementation 
 * of some SSJ classes.  See the SSJ installation instructions for how to 
 * install them on your computer.
 *
 * The [Colt library](http://acs.lbl.gov/software/colt/)
 * , developed at the Centre Européen de Recherche Nucléaire (CERN) in Geneva
 * @cite iHOS04a&thinsp;, is a large library that provides a wide range of
 * facilities for high performance scientific and technical computing in
 * Java. SSJ uses the class  DoubleArrayList from Colt in a few of its
 * classes, namely in packages  @ref umontreal.ssj.stat and
 * @ref umontreal.ssj.hups. The reason is that this class provides a very
 * efficient and convenient implementation of an (automatically) extensible
 * array of <tt>double</tt>, together with several methods for computing
 * statistics for the observations stored in the array (see, e.g.,
 * <tt>Descriptive</tt>). The Colt library is distributed with the SSJ
 * package as **colt.jar**. It must be added in the CLASSPATH environment
 * variable.
 *
 * The optimization package of Steve Verrill includes Java translations of
 * the [MINPACK](http://simul.iro.umontreal.ca/Uncmin_f77/Minpack_f77.html)
 *  routines @cite iMOR80a&thinsp; for nonlinear least squares problems as
 * well as [UNCMIN](http://simul.iro.umontreal.ca/Uncmin_f77/Uncmin_f77.html)
 *  routines @cite iSCHa&thinsp; for unconstrained optimization. They were
 * translated from Fortran to Java by Steve Verrill 
 * at the USDA Forest Products Laboratory Madison, Wisconsin, USA, and are in the public
 * domain. They are included in the SSJ distribution as the
 * **optimization.jar** archive. It is used only in @ref umontreal.ssj.probdist to
 * compute maximum likelihood estimators.
 * This archive also contains the  <strong>linear_algebra</strong> library, based on public domain
 * LINPACK routines, also translated from Fortran to Java by Steve Verrill.
 *
 * [JFreeChart](http://www.jfree.org/jfreechart/index.html)
 *  is a free Java library that can generate a wide variety of charts and
 * plots for use in applications, applets and servlets. **JFreeChart**
 * currently supports, amongst others, bar charts, pie charts, line charts,
 * XY-plots, histograms, scatter plots and time series plots. It is
 * distributed with SSJ as **jfreechart-*.jar**.
 * [JCommon](http://www.jfree.org/jcommon/index.php)
 *  is a free general purpose Java library containing many useful classes
 * used by JFreeChart and other Java packages. It is distributed with SSJ as
 * **jcommon-*.jar**. JFreeChart (and JCommon) are used in the SSJ package
 * **charts** to create different kinds of charts.
 *
 * SSJ also provides an interface to the
 * [UNURAN](http://statistik.wu-wien.ac.at/unuran/)
 *  library for nonuniform random number generation @cite iLEY02a&thinsp;, in
 * the  @ref umontreal.ssj.randvar package. UNURAN does not have to be
 * installed to be used with SSJ, because it is linked statically with the
 * appropriate SSJ native library. However, the UNURAN documentation will be
 * required to take full advantage of the library.
 * 
 * #Update:  use of jcommon, concurrent, ...   interface to Latnet Builder.
 * 
 * 
 ************************************************************************
 * @section REF_0_sec_03  Structure of the Library (Quick Overview)
 * 
 * ## Random Number and Random Variate Generation
 * 
 * 
 * Random numbers feed simulation models and allow one to compute statistics.
 * To generate random numbers from any probability distribution, uniform
 * random numbers are required. Such numbers are uniformly distributed in the
 * @f$[0,1)@f$ interval, i.e., the probability of getting a given number
 * @f$x@f$ in that interval is the same for all values of @f$x\in[0,1)@f$.
 * Any generated number @f$x@f$ is also independent from any previous or
 * future generated numbers. Although the generated uniforms are not truly
 * independent since one uniform is obtained from the previous uniforms by a
 * mathematical formula, one can consider them independent for simulation
 * purposes. Selection of a random number generator is based on several
 * criteria such as uniformity, performance, and portability
 * @cite rLEC01d&thinsp;. The package  @ref umontreal.ssj.rng contains the
 * needed tools to generate such numbers. It defines an interface called
 * @ref umontreal.ssj.rng.RandomStream implemented by any random number
 * generator supported by SSJ. This interface allows one to easily
 * interchange random number generators since they are accessed through the
 * same set of methods specified by the interface. Only the random number
 * generator setup depends on the type of generator that was chosen.
 *
 * If one wants to replace uniform random numbers with low-discrepancy point
 * sets for variance reduction, the package  @ref umontreal.ssj.hups contains
 * all the necessary facilities. Such highly uniform point sets all inherit
 * from the  @ref umontreal.ssj.hups.PointSet which provides a
 * @ref umontreal.ssj.hups.PointSetIterator extending
 * @ref umontreal.ssj.rng.RandomStream. The replacement can be easily done
 * without modifying the model implementation, except the setup-time code.
 *
 * To generate non-uniform random numbers, one must select a probability
 * distribution based on the empirical data @cite sLAW00a&thinsp;. SSJ does
 * not provide probability distribution estimation tools, but goodness of fit
 * tests are included to help in model validation. The package
 * @ref umontreal.ssj.probdist contains several standard, commonly-used,
 * probability distributions. It supports discrete and continuous
 * distributions through two different abstract base classes:
 * @ref umontreal.ssj.probdist.ContinuousDistribution and
 * @ref umontreal.ssj.probdist.DiscreteDistribution, respectively. Again,
 * since the distributions inherit from a common class, their access can be
 * independent from the selected distribution, except for the setup case. One
 * can compute the density/mass, distribution, complementary, and inverse
 * distribution functions. These facilities are also accessible through
 * static methods implemented in each distribution class if one does not want
 * to create objects or needs distributions whose parameters vary in time.
 * However, setup-time operations must be performed for each operation, which
 * can be inefficient for certain distributions.
 *
 * To generate non-uniform random numbers, the packages
 * @ref umontreal.ssj.rng (or  @ref umontreal.ssj.hups ) and
 * @ref umontreal.ssj.probdist must be used together. The simplest generation
 * method is to generate a uniform random number using a generator
 * implementing  @ref umontreal.ssj.rng.RandomStream (or get a coordinate
 * using a point set iterator) and to apply inversion by using the selected
 * @ref umontreal.ssj.probdist distribution’s
 * umontreal.ssj.probdist.ContinuousDistribution.inverseF method. However,
 * inversion is not the only generation method and sometimes not the most
 * efficient. For some distributions, closed-form inverse functions or fast
 * inversion algorithms exist. For others, inversion is performed using
 * binary or even linear search. In such cases, the performance and precision
 * depends on the complexity of the distribution function which is calculated
 * several times for one inverse. The package  @ref umontreal.ssj.randvar
 * acts as glue between uniform random number generators and probability
 * distributions. Continuous or discrete random number generators also
 * inherits from common base classes, namely
 * @ref umontreal.ssj.randvar.RandomVariateGen and
 * @ref umontreal.ssj.randvar.RandomVariateGenInt. All generators use a
 * random stream and a probability distribution for their construction. As
 * opposed to  @ref umontreal.ssj.probdist, one can directly instantiate
 * @ref umontreal.ssj.randvar.RandomVariateGen or
 * @ref umontreal.ssj.randvar.RandomVariateGenInt. However, in such cases,
 * only inversion generation method will be available. To use an alternate
 * generation method, one must instantiate a specialized generator class and
 * switch to the given generation algorithm using an object method. Each
 * specialized class also provides static method which perform the same
 * action. Although they allow one to avoid object creation, their signatures
 * are specific to the used distribution and they have to perform setup-time
 * operations on each variate generation, which can become inefficient. 
 * 
 * 
 * 
 * ## Statistical Tools 
 * 
 * The package  @ref umontreal.ssj.stat provides basic tools for statistical
 * collection. Statistics are collected using statistical probes, i.e,
 * objects implementing the abstract class
 * @ref umontreal.ssj.stat.StatProbe. Two types of probes are supported. The
 * @ref umontreal.ssj.stat.Tally allows to collect observations of the form
 * @f$X_1,…,X_n@f$ whereas  @ref umontreal.ssj.simevents.Accumulate collects
 * statistics for a continuous variable evolving in simulation time. During
 * the simulation, one can add observations to such probes. After the
 * simulation, measures can be obtained, such as sample average, sample
 * standard deviation or confidence interval. A statistical report can be
 * obtained for all probes. The package also provides a way to detach
 * statistical collection from the model implementation by using bound
 * properties.
 *
 * To test a proposed model against empirical data, goodness of fit tests are
 * provided in the package  @ref umontreal.ssj.gof. Such tests, e.g.
 * Kolmogorov-Smirnov or Anderson-Darling, compute a statistic using the
 * empirical observations and the proposed distribution. The empirical
 * observations are given as an array whereas the distribution is given as a
 * @ref umontreal.ssj.probdist object. From the computed statistic, it is
 * possible to compute the @f$p@f$-value which is useful to evaluate the
 * significance of the test.
 * 
 * 
 * ## Running Simulation Experiments
 *  
 * SSJ supports discrete-event, process-driven, continuous or mixed
 * simulation. The discrete-event and continuous simulation are managed by
 * the package  @ref umontreal.ssj.simevents. This package manages the
 * simulation clock and the event list, two essential components for all
 * discrete-event simulations. The simulation clock tracks the simulation
 * time whereas the event list stores the scheduled events to execute them in
 * the right order. Events are user-defined subclasses of
 * @ref umontreal.ssj.simevents.Event. When an event occurs, any type of
 * actions can then be taken. The package provides a class called
 * @ref umontreal.ssj.simevents.LinkedListStat<E> which implements a linked list
 * supporting statistical collection. Continuous simulation can be performed
 * using the class  @ref umontreal.ssj.simevents.Continuous. It uses the
 * event framework to resolve differential equations numerically at fixed
 * steps in the simulation time.
 *
 *
 *********************************************************************** 
 * @section REF_0_sec_04  Documentation
 * 
 * 
 * The `example.pdf` file, in the `doc/pdf` subdirectory of the SSJ
 * distribution, explains simulation examples implemented using SSJ. This may
 * be the best starting point to learn SSJ.
 * O
 * ne can find additional information and references in the PDF version of
 * this documentation, available in the <tt>doc/pdf</tt> subdirectory of the
 * SSJ distribution.
 *
 *  very package introduced here contains its own reference documentation as
 * a PDF file, in the `doc/pdf` subdirectory. This documentation describes in
 * more details how to use the package and provides a description of each
 * class and method.
 * 
 * 
 ************************************************************************** 
 * @section ssj_acknowledgments Acknowledgments
 * 
 * 
 * SSJ was designed and implemented under the supervision of Pierre L’Ecuyer.
 * A first version was released around 2001.  
 * The following people (by alphabetic order) have contributed significantly to SSJ:
 *
 * Mathieu Bague, Sylvain Bonnet, Éric Buist, Wyean Chan, Maxime Dion, Yves Edel, Regina
 * H. S. Hong, Alexander Keller, Pierre L'Ecuyer, Étienne Marcotte, Lakhdar
 * Meliani, David Munger, François Panneton, Florian Puchhammer, Jean-Sebastien Parent-Chartier, Richard
 * Simard, Clément Teule, Pierre-Alexandre Tremblay, Jean Vaucher.
 *
 * The development of SSJ has been supported by NSERC-Canada grant No. ODGP0110050,
 * NATEQ-Québec grant No. 02ER3218, a Killam fellowship, and a Canada
 * Research Chair to P. L'Ecuyer.
 */
