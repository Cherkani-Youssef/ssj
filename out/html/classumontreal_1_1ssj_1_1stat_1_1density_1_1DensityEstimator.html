<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DensityEstimator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ssj.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">Stochastic Simulation in Java</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>umontreal</b></li><li class="navelem"><b>ssj</b></li><li class="navelem"><a class="el" href="namespaceumontreal_1_1ssj_1_1stat.html">stat</a></li><li class="navelem"><a class="el" href="namespaceumontreal_1_1ssj_1_1stat_1_1density.html">density</a></li><li class="navelem"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html">DensityEstimator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DensityEstimator Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This abstract class implements a univariate density estimator (DE).  
 <a href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for DensityEstimator:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator__inherit__graph.svg" width="467" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4ae7a74e0d3483a0988280dd0eb64507"><td class="memItemLeft" align="right" valign="top">abstract double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a4ae7a74e0d3483a0988280dd0eb64507">evalDensity</a> (double x, double data[], double a, double b)</td></tr>
<tr class="memdesc:a4ae7a74e0d3483a0988280dd0eb64507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a density estimator over the interval \([a,b]\) based on the observations <em>data</em>, if necessary, and evaluates it at <em>x</em>.  <a href="#a4ae7a74e0d3483a0988280dd0eb64507">More...</a><br /></td></tr>
<tr class="separator:a4ae7a74e0d3483a0988280dd0eb64507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbdd6f5065f79e10a18bd40de194047"><td class="memItemLeft" align="right" valign="top">double []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#acbbdd6f5065f79e10a18bd40de194047">evalDensity</a> (double[] evalPoints, double[] data, double a, double b)</td></tr>
<tr class="memdesc:acbbdd6f5065f79e10a18bd40de194047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a density estimator over the interval \([a,b]\) based on the observations <em>data</em>, if necessary, and evaluates it at the points in <em>evalPoints</em>.  <a href="#acbbdd6f5065f79e10a18bd40de194047">More...</a><br /></td></tr>
<tr class="separator:acbbdd6f5065f79e10a18bd40de194047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8851d69d34aac9a40105635616957ade"><td class="memItemLeft" align="right" valign="top">double [][]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a8851d69d34aac9a40105635616957ade">evalDensity</a> (double[] evalPoints, double[][] data, double a, double b)</td></tr>
<tr class="memdesc:a8851d69d34aac9a40105635616957ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is particularly designed to evaluate the density estimator in such a way that the result can be easily used to estimate the empirical IV and other convergence-related quantities.  <a href="#a8851d69d34aac9a40105635616957ade">More...</a><br /></td></tr>
<tr class="separator:a8851d69d34aac9a40105635616957ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e2151cf49df9f80a4999e0e9e54d55"><td class="memItemLeft" align="right" valign="top">abstract String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a77e2151cf49df9f80a4999e0e9e54d55">toString</a> ()</td></tr>
<tr class="memdesc:a77e2151cf49df9f80a4999e0e9e54d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives a short description of the estimator.  <a href="#a77e2151cf49df9f80a4999e0e9e54d55">More...</a><br /></td></tr>
<tr class="separator:a77e2151cf49df9f80a4999e0e9e54d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac865ef1dc103098636c45ccc2248a42a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#ac865ef1dc103098636c45ccc2248a42a">evalDensity</a> (ArrayList&lt; <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html">DensityEstimator</a> &gt; listDE, double[] evalPoints, double[][] data, double a, double b, ArrayList&lt; double[][]&gt; listDensity)</td></tr>
<tr class="memdesc:ac865ef1dc103098636c45ccc2248a42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is particularly designed for experiments with many different types of density estimators, as it evaluates all of these estimators at the points in <em>evalPoints</em>.  <a href="#ac865ef1dc103098636c45ccc2248a42a">More...</a><br /></td></tr>
<tr class="separator:ac865ef1dc103098636c45ccc2248a42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f04c4763dc6c1d50ab0c277a2ddfc9"><td class="memItemLeft" align="right" valign="top">static double []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a16f04c4763dc6c1d50ab0c277a2ddfc9">computeVariance</a> (double[][] density)</td></tr>
<tr class="memdesc:a16f04c4763dc6c1d50ab0c277a2ddfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method computes the empirical variance based on the values given in <em>data</em>.  <a href="#a16f04c4763dc6c1d50ab0c277a2ddfc9">More...</a><br /></td></tr>
<tr class="separator:a16f04c4763dc6c1d50ab0c277a2ddfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9c290eebf7cdc7d4ebcf883fe90b88"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#aca9c290eebf7cdc7d4ebcf883fe90b88">computeIV</a> (double[][] density, double a, double b, double[] variance)</td></tr>
<tr class="memdesc:aca9c290eebf7cdc7d4ebcf883fe90b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method estimates the empirical IV over the interval \([a,b]\).  <a href="#aca9c290eebf7cdc7d4ebcf883fe90b88">More...</a><br /></td></tr>
<tr class="separator:aca9c290eebf7cdc7d4ebcf883fe90b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650c049ba7e2d47161c6796b6dc5b5cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a650c049ba7e2d47161c6796b6dc5b5cc">computeIV</a> (ArrayList&lt; double[][]&gt; listDensity, double a, double b, ArrayList&lt; Double &gt; listIV)</td></tr>
<tr class="memdesc:a650c049ba7e2d47161c6796b6dc5b5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method estimates the empirical IV over the interval \([a,b]\) for a collection of different estimators.  <a href="#a650c049ba7e2d47161c6796b6dc5b5cc">More...</a><br /></td></tr>
<tr class="separator:a650c049ba7e2d47161c6796b6dc5b5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8349c434950e5c5c6e245e3928cb96ac"><td class="memItemLeft" align="right" valign="top">static double []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a8349c434950e5c5c6e245e3928cb96ac">computeMISE</a> (<a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html">ContinuousDistribution</a> dist, double[] evalPoints, double[][] density, double a, double b, double[] variance, double[] sqBias, double[] mse)</td></tr>
<tr class="memdesc:a8349c434950e5c5c6e245e3928cb96ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">In situations where the true density is known this method can estimate the empirical MISE over the interval \([a,b]\).  <a href="#a8349c434950e5c5c6e245e3928cb96ac">More...</a><br /></td></tr>
<tr class="separator:a8349c434950e5c5c6e245e3928cb96ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed45f859027b55025865ecec4014c1ea"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#aed45f859027b55025865ecec4014c1ea">computeMISE</a> (<a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html">ContinuousDistribution</a> dist, double[] evalPoints, ArrayList&lt; double[][]&gt; listDensity, double a, double b, ArrayList&lt; double[]&gt; listMISE)</td></tr>
<tr class="memdesc:aed45f859027b55025865ecec4014c1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method estimates the empirical MISE over the interval \([a,b]\) for a collection of different estimators.  <a href="#aed45f859027b55025865ecec4014c1ea">More...</a><br /></td></tr>
<tr class="separator:aed45f859027b55025865ecec4014c1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b223706dc90bab33746a61504e7be95"><td class="memItemLeft" align="right" valign="top">static String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a7b223706dc90bab33746a61504e7be95">plotDensity</a> (double[] evalPoints, double[] density, String plotTitle, String[] axisTitles)</td></tr>
<tr class="memdesc:a7b223706dc90bab33746a61504e7be95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives a plot of the estimated density.  <a href="#a7b223706dc90bab33746a61504e7be95">More...</a><br /></td></tr>
<tr class="separator:a7b223706dc90bab33746a61504e7be95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a88d2d3720ac775f5953b35ac0a504a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a3a88d2d3720ac775f5953b35ac0a504a">roughnessFunctional</a> (double[] density, double a, double b)</td></tr>
<tr class="memdesc:a3a88d2d3720ac775f5953b35ac0a504a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the roughness functional.  <a href="#a3a88d2d3720ac775f5953b35ac0a504a">More...</a><br /></td></tr>
<tr class="separator:a3a88d2d3720ac775f5953b35ac0a504a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:aa23a0438bd7545bd76b2814b057a7479"><td class="memItemLeft" align="right" valign="top">static double []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#aa23a0438bd7545bd76b2814b057a7479">estimateMeanAndStdDeviation</a> (double[] data)</td></tr>
<tr class="memdesc:aa23a0438bd7545bd76b2814b057a7479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean and the standard deviation of the observations given in <em>data</em>.  <a href="#aa23a0438bd7545bd76b2814b057a7479">More...</a><br /></td></tr>
<tr class="separator:aa23a0438bd7545bd76b2814b057a7479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b36eb5320db688d7745431380f95299"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a6b36eb5320db688d7745431380f95299">coefficientOfDetermination</a> (double[] data, double[] dataEstimated)</td></tr>
<tr class="memdesc:a6b36eb5320db688d7745431380f95299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Coefficient of determination \(R^2\) of the observed data <em>data</em> and the estimated data <em>dataEstimated</em>.  <a href="#a6b36eb5320db688d7745431380f95299">More...</a><br /></td></tr>
<tr class="separator:a6b36eb5320db688d7745431380f95299"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This abstract class implements a univariate density estimator (DE). </p>
<p>To this end, it provides basic tools to evaluate the DE at one point \(x\) or at an array of points \(\{x_1, x_2, \dots, x_k\} \). More precisely, the single point evaluation <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a4ae7a74e0d3483a0988280dd0eb64507" title="Constructs a density estimator over the interval  based on the observations data, if necessary...">evalDensity(double, double[], double, double)</a> is abstract, since it will definitely differ between realizations. For the evaluation on a set of points one can use #evalDensity(double[], double[], double, double). Note that, even though a default implementation is provided, very often specific estimators will have more efficient evaluation algorithms. So, overriding this method can be beneficial in many cases. Furthermore, this class includes a method to plot the estimated density.</p>
<p>There are also several more involved methods covered by this class, most of which are concerned with the convergence behavior of DEs. Nevertheless, they can be useful in many other cases beyond convergence behavior. As these usually require more than one realization of a DE, or even a list of DE's, they are implemented as static methods. For instance, <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a4ae7a74e0d3483a0988280dd0eb64507" title="Constructs a density estimator over the interval  based on the observations data, if necessary...">evalDensity</a>(double[], double[][], double, double) allows to evaluate several independent replications of a DE at an array of evaluation points, and #evalDensity(ArrayList, double[], double[][], double, double, ArrayList) does the same but for more than one DE.</p>
<p>For measuring the performance of a DE, we need to confine ourselves to estimation over a finite interval \([a,b]\). One standard way to assess the quality of a DE is via the mean integrated square error (MISE). It can be further decomposed into the integrated variance (IV), and the integrated square bias (ISB)</p>
<p class="formulaDsp">
\[ \textrm{MISE} = \int_a^b\mathbb{E} [\hat{f}(x) - f(x)]^2\mathrm{d}x = \int_a^b\textrm{Var}[\hat{f}(x)]\mathrm{d}x + \int_a^b \left( \mathbb{E}[\hat{f}(x)] - f(x) \right)^2\mathrm{d}x, \]
</p>
<p>where \(f\) denotes the true density and \(\hat{f}\) the DE.</p>
<p>This class also provides methods to estimate the empirical IV, see #computeIV(double[][], double, double, double[]) for one individual DE and #computeIV(ArrayList, double, double, ArrayList) for several DEs. Note that these mehtods merely compute an estimate, since computing an exact integral is out of reach for this class.</p>
<p>Note that the MISE can only be computed in situations where either the ISB is zero or the true density is known. In the first case, the IV is the same as the MISE, of course. For the second case this class provides the possibility to estimate the empirical MISE for a single DE via <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a8349c434950e5c5c6e245e3928cb96ac" title="In situations where the true density is known this method can estimate the empirical MISE over the in...">computeMISE</a>(ContinuousDistribution, double[], double[][], double, double, double[], double[], double[])} as well as for several DEs via <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a8349c434950e5c5c6e245e3928cb96ac" title="In situations where the true density is known this method can estimate the empirical MISE over the in...">computeMISE</a>(ContinuousDistribution, double[], ArrayList, double, double, ArrayList). Again, this merely gives an estimate of the empirical MISE. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6b36eb5320db688d7745431380f95299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b36eb5320db688d7745431380f95299">&#9670;&nbsp;</a></span>coefficientOfDetermination()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double coefficientOfDetermination </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>dataEstimated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Coefficient of determination \(R^2\) of the observed data <em>data</em> and the estimated data <em>dataEstimated</em>. </p>
<p>For observed data \(y=(y_1,y_2,\dots,y_n)\) and estimated data \( f=(f_1,f_2,\dots,f_n)\) this is defined as </p><p class="formulaDsp">
\[ R^2 = 1 - \frac{\textrm{SS}_{\text{res}}}{\textrm{SS}_{\text{tot}}}, \]
</p>
<p> where \( \textrm{SS}_{\text{res}} \) denotes the sum of squares of the residuals </p><p class="formulaDsp">
\[ \textrm{SS}_{\text{res}} = \sum_{i=1}^n (f_i - y_i)^2 \]
</p>
<p> and where \(\textrm{SS}_{\text{tot}}\) is the total sum of squares </p><p class="formulaDsp">
\[ \textrm{SS}_{\text{tot}} = \sum_{i=1}^n (y_i - \bar{y})^2. \]
</p>
<p> The closer this quantity is to one, the better the approximation of \(y\) by \(f\).</p>
<dl class="section remark"><dt>Remarks</dt><dd><b>Florian:</b> this should probably go somewhere else (stat? we do not need it for dens. est. per-se).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the observed data </td></tr>
    <tr><td class="paramname">dataEstimated</td><td>the estimated data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Coefficient of determination \(R^2\) </dd></dl>

</div>
</div>
<a id="aca9c290eebf7cdc7d4ebcf883fe90b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9c290eebf7cdc7d4ebcf883fe90b88">&#9670;&nbsp;</a></span>computeIV() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double computeIV </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>density</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>variance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method estimates the empirical IV over the interval \([a,b]\). </p>
<p>Based on the density estimates of \(m\) independent replications of the density estimator evaluated at \(k\) evaluation points, which are provided by <em>density</em>, it computes the empirical variance at each evaluation point and stores it in <em>variance</em>.</p>
<p>To estimate the empirical IV, we sum up the variance at the evaluation points \(x_1,x_2,\dots,x_k\) and multiply by \((b-a)/k\), i.e.</p>
<p class="formulaDsp">
\[ \int_a^b \hat{f}(x)\mathrm{d}x \approx \frac{b-a}{k} \sum_{j = 1}^k\hat{f}(x_j), \]
</p>
<p>where \(\hat{f}\) denotes the density estimator. In other words, we approximate the empirical IV by an equally weighted quadrature rule using the aforementioned evaluation points as integration nodes.</p>
<p>Note that this is only an approximation of the true empirical IV and that the approximation quality significantly depends on the choice of evaluation points.</p>
<p>The data for the variance are given in the two-dimensional \(m\times k\) array <em>density</em>, which is also described in <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a16f04c4763dc6c1d50ab0c277a2ddfc9" title="This method computes the empirical variance based on the values given in data. ">computeVariance(double[][])</a> and can be obtained by #evalDensity(double[], double[][], double, double) . The boundaries of the interval are given by <em>a</em> and <em>b</em>. Note that the array <em>variance</em> needs to be of length \(k\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">density</td><td>the \(m\times k\) array that contains the data of evaluating \(m\) replicates of the density estimator at \(k\) evaluation points </td></tr>
    <tr><td class="paramname">a</td><td>the left boundary of the interval. </td></tr>
    <tr><td class="paramname">b</td><td>the right boundary of the interval. </td></tr>
    <tr><td class="paramname">variance</td><td>the array of length \(k\) in which the variance at each evaluation point is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the estimated empirical IV over \([a,b]\). </dd></dl>

</div>
</div>
<a id="a650c049ba7e2d47161c6796b6dc5b5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650c049ba7e2d47161c6796b6dc5b5cc">&#9670;&nbsp;</a></span>computeIV() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void computeIV </td>
          <td>(</td>
          <td class="paramtype">ArrayList&lt; double[][]&gt;&#160;</td>
          <td class="paramname"><em>listDensity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayList&lt; Double &gt;&#160;</td>
          <td class="paramname"><em>listIV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method estimates the empirical IV over the interval \([a,b]\) for a collection of different estimators. </p>
<p>In <em>densityList</em> the user passes a list of \(m\times k\) arrays which contain the density estimates of \(m\) independent replications of each density estimator evaluated at \(k\) evaluation points. Such a list can be obtained via <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a4ae7a74e0d3483a0988280dd0eb64507" title="Constructs a density estimator over the interval  based on the observations data, if necessary...">evalDensity</a>(ArrayList, double[], double[][], double, double, ArrayList) , for instance.</p>
<p>The method then calls #computeIV(double[][], double, double, double[]) for each element of <em>densityList</em> and adds the thereby obtained estimated empirical IV to the list that is being returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listDensity</td><td>list containing \(m\times k\) arrays that contain the data of evaluating \(m\) replicates of each density estimator at \(k\) evaluation points <em>evalPoints</em>. </td></tr>
    <tr><td class="paramname">a</td><td>the left boundary of the interval. </td></tr>
    <tr><td class="paramname">b</td><td>the right boundary of the interval. </td></tr>
    <tr><td class="paramname">listIV</td><td>the list to which the estimated empirical IV of each density estimator will be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><b>Florian:</b> I kept the return type as "void" instead of "ArrayList&lt;double[][]&gt;" and pass the corresponding list <em>listDensity</em> to allow for more flexibility when working with it. </dd></dl>

</div>
</div>
<a id="a8349c434950e5c5c6e245e3928cb96ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8349c434950e5c5c6e245e3928cb96ac">&#9670;&nbsp;</a></span>computeMISE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double [] computeMISE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html">ContinuousDistribution</a>&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>evalPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>density</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>variance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>sqBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>mse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In situations where the true density is known this method can estimate the empirical MISE over the interval \([a,b]\). </p>
<p>This can be particularly interesting and useful for testing density estimators. Since it is necessary to compute either the ISB or the IV to get the MISE and as there is not much computational overhead to estimate the other, an array containing the estimated empirical IV, the ISB, and MISE in exactly this order is returned. Based on the density estimates of \(m\) independent replications of the density estimator evaluated at \(k\) evaluation points <em>evalPoints</em>, which are provided by <em>density</em>, it computes the empirical variance, the square-bias, and the mean square error (MSE) at each evaluation point and stores the result in <em>variance</em>, <em>sqBias</em>, and <em>mse</em>, respectively. It is important that the evaluation points in <em>evalPoints</em> are the same as the ones used to construct <em>density</em>.</p>
<p>To estimate the empirical IV and MISE we sum up the variance and the MSE at the \(k\) evaluation points and multiply by \((b-a)/k\), i.e. we approximate the empirical IV by an equally weighted quadrature rule with <em>evalPoints</em> as integration nodes. The ISB is then computed as the difference of the MISE and the IV. Note that this is only an approximation of the true empirical values and that the approximation quality significantly depends on the choice of <em>evalPoints</em>.</p>
<p>The data for the variance and mse are given in the two-dimensional \(m\times k\) array <em>density</em>, which is also described in <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a16f04c4763dc6c1d50ab0c277a2ddfc9" title="This method computes the empirical variance based on the values given in data. ">computeVariance(double[][])</a> and can be obtained by <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a4ae7a74e0d3483a0988280dd0eb64507" title="Constructs a density estimator over the interval  based on the observations data, if necessary...">evalDensity</a>(double[], double[][], double, double), and the true density is passed via a <a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html">umontreal.ssj.probdist.ContinuousDistribution</a>. The evaluation points are contained in <em>evalPoints</em> and the boundaries of the interval over which we estimate are given by <em>a</em> and <em>b</em>. Note that the arrays <em>variance</em>, <em>sqBias</em>, and <em>mse</em> need to be of length \(k\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist</td><td>the true density. </td></tr>
    <tr><td class="paramname">evalPoints</td><td>the \(k\) evaluation points. </td></tr>
    <tr><td class="paramname">density</td><td>the \(m\times k\) array that contains the data of evaluating \(m\) replicates of the density estimator at \(k\) evaluation points <em>evalPoints</em>. </td></tr>
    <tr><td class="paramname">a</td><td>the left boundary of the interval. </td></tr>
    <tr><td class="paramname">b</td><td>the right boundary of the interval. </td></tr>
    <tr><td class="paramname">variance</td><td>the array of length \(k\) in which the variance at each evaluation point is stored. </td></tr>
    <tr><td class="paramname">sqBias</td><td>the array of length \(k\) in which the square-bias at each evaluation point is stored. </td></tr>
    <tr><td class="paramname">mse</td><td>the array of length \(k\) in which the MSE at each evaluation point is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array containing the estimated empirical IV, ISB, and MISE in exactly this order. </dd></dl>

</div>
</div>
<a id="aed45f859027b55025865ecec4014c1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed45f859027b55025865ecec4014c1ea">&#9670;&nbsp;</a></span>computeMISE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void computeMISE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classumontreal_1_1ssj_1_1probdist_1_1ContinuousDistribution.html">ContinuousDistribution</a>&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>evalPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayList&lt; double[][]&gt;&#160;</td>
          <td class="paramname"><em>listDensity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayList&lt; double[]&gt;&#160;</td>
          <td class="paramname"><em>listMISE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method estimates the empirical MISE over the interval \([a,b]\) for a collection of different estimators. </p>
<p>This can be done when the true density is actually known and is particularly interesting and/or useful for testing density estimators.</p>
<p>In <em>densityList</em> the user passes a list of \(m\times k\) arrays which contain the density estimates of \(m\) independent replications of each density estimator evaluated at \(k\) evaluation points. Such a list can be obtained by calling <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a4ae7a74e0d3483a0988280dd0eb64507" title="Constructs a density estimator over the interval  based on the observations data, if necessary...">evalDensity</a>(ArrayList, double[], double[][], double, double), for instance.</p>
<p>The method then calls <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a8349c434950e5c5c6e245e3928cb96ac" title="In situations where the true density is known this method can estimate the empirical MISE over the in...">computeMISE</a>(ContinuousDistribution, double[], double[][], double, double, double[], double[], double[]) for each element of <em>listDensity</em>. This results in an array containing the estimated empirical IV, ISB, and MISE in exactly this order, which is then added to the list <em>listMISE</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist</td><td>the true density. </td></tr>
    <tr><td class="paramname">evalPoints</td><td>the \(k\) evaluation points. </td></tr>
    <tr><td class="paramname">listDensity</td><td>list containing \(m\times k\) arrays that contain the data of evaluating \(m\) replicates of each density estimator at \(k\) evaluation points <em>evalPoints</em>. </td></tr>
    <tr><td class="paramname">a</td><td>the left boundary of the interval. </td></tr>
    <tr><td class="paramname">b</td><td>the right boundary of the interval. </td></tr>
    <tr><td class="paramname">listMISE</td><td>a list to which the arrays containing the estimated empirical IV, ISB, and MISE of each density estimator are added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><b>Florian:</b> I kept the return type as "void" instead of "ArrayList&lt;double[][]&gt;" and pass the corresponding list <em>listDensity</em> to allow for more flexibility when working with it. </dd></dl>

</div>
</div>
<a id="a16f04c4763dc6c1d50ab0c277a2ddfc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f04c4763dc6c1d50ab0c277a2ddfc9">&#9670;&nbsp;</a></span>computeVariance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double [] computeVariance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>density</em>[][]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method computes the empirical variance based on the values given in <em>data</em>. </p>
<p>More precisely, <em>density</em> is a \(m\times k\) matrix, whose entries correspond to \(m\) independent realizations of the density estimator, each evaluated at \(k\) evaluation points. Such a matrix can, for instance, be obtained by #evalDensity(double[], double[][], double, double).</p>
<p>The empirical variance is computed at each of those \(k \) evaluation points and returned in an array of size \(k\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">density</td><td>the estimated density of \(m\) independent realizations of the estimator, each evaluated at \(k\) evaluation points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the empirical variance at those \(k\) evaluation points. </dd></dl>

</div>
</div>
<a id="aa23a0438bd7545bd76b2814b057a7479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23a0438bd7545bd76b2814b057a7479">&#9670;&nbsp;</a></span>estimateMeanAndStdDeviation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double [] estimateMeanAndStdDeviation </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean and the standard deviation of the observations given in <em>data</em>. </p>
<dl class="section remark"><dt>Remarks</dt><dd><b>Florian:</b> this should probably go somewhere else (DEDerivative as Private?)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mean and standard deviation. </dd></dl>

</div>
</div>
<a id="a4ae7a74e0d3483a0988280dd0eb64507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae7a74e0d3483a0988280dd0eb64507">&#9670;&nbsp;</a></span>evalDensity() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract double evalDensity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">abstract</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a density estimator over the interval \([a,b]\) based on the observations <em>data</em>, if necessary, and evaluates it at <em>x</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the evaluation point. </td></tr>
    <tr><td class="paramname">data</td><td>the observations for constructing the density estimator. </td></tr>
    <tr><td class="paramname">a</td><td>the left boundary of the interval. </td></tr>
    <tr><td class="paramname">b</td><td>the right boundary of the interval </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the density estimator evaluated at \(x\). </dd></dl>

</div>
</div>
<a id="acbbdd6f5065f79e10a18bd40de194047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbdd6f5065f79e10a18bd40de194047">&#9670;&nbsp;</a></span>evalDensity() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double [] evalDensity </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>evalPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a density estimator over the interval \([a,b]\) based on the observations <em>data</em>, if necessary, and evaluates it at the points in <em>evalPoints</em>. </p>
<p>By default, this method calls <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html#a4ae7a74e0d3483a0988280dd0eb64507" title="Constructs a density estimator over the interval  based on the observations data, if necessary...">evalDensity</a>(double, double[], double, double) for each entry of <em>evalPoints</em>. Many density estimators can handle evaluation at a set of points more efficiently than that. If so, it is suggested to override this method in the implementation of the corresponding estimator. Note that the construction of the density estimator &ndash; if applicable &ndash; would need to be handled by this method as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evalPoints</td><td>the evaluation points. </td></tr>
    <tr><td class="paramname">data</td><td>the observations for constructing the density estimator. </td></tr>
    <tr><td class="paramname">a</td><td>the left boundary of the interval. </td></tr>
    <tr><td class="paramname">b</td><td>the right boundary of the interval </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the density estimator evaluated at the points <em>evalPoints</em>. </dd></dl>

</div>
</div>
<a id="a8851d69d34aac9a40105635616957ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8851d69d34aac9a40105635616957ade">&#9670;&nbsp;</a></span>evalDensity() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double [][] evalDensity </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>evalPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>data</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is particularly designed to evaluate the density estimator in such a way that the result can be easily used to estimate the empirical IV and other convergence-related quantities. </p>
<p>Assume that we have \(m\) independent realizations of the underlying model. For each such realization this method constructs a density estimator over \([a,b]\) and evaluates it at the points from <em>evalPoints</em>. The independent realizations are passed via the 2-dimensional \(m\times n\) <em>data</em>, where \(n\) denotes the number of observations per realization. Hence, its first index identifies the independent realization while its second index identifies a specific observation of this realization.</p>
<p>The result is returned as a \(m\times k\) matrix, where \(k \) is the number of evaluation points, i.e., the length of <em>evalPoints</em>. The first index, again, identifies the independent realization whereas the second index corresponds to the point of <em>evalPoints</em> at which the density estimator was evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evalPoints</td><td>the evaluation points. </td></tr>
    <tr><td class="paramname">data</td><td>the two-dimensional array carrying the observations of \(m\) independent realizations of the underlying model. </td></tr>
    <tr><td class="paramname">a</td><td>the left boundary of the interval. </td></tr>
    <tr><td class="paramname">b</td><td>the right boundary of the interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the density estimator for each realization evaluated at <em>evalPoints</em>. </dd></dl>

</div>
</div>
<a id="ac865ef1dc103098636c45ccc2248a42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac865ef1dc103098636c45ccc2248a42a">&#9670;&nbsp;</a></span>evalDensity() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evalDensity </td>
          <td>(</td>
          <td class="paramtype">ArrayList&lt; <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1density_1_1DensityEstimator.html">DensityEstimator</a> &gt;&#160;</td>
          <td class="paramname"><em>listDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>evalPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>data</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayList&lt; double[][]&gt;&#160;</td>
          <td class="paramname"><em>listDensity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is particularly designed for experiments with many different types of density estimators, as it evaluates all of these estimators at the points in <em>evalPoints</em>. </p>
<p>To this end, the user passes a list of density estimators in <em>listDE</em> as well as \(m\) independent realizations of the underlying model consisting of \(n\) observations each in the \(m\times n\) array <em>data</em>.</p>
<p>This method then calls #evalDensity(double[], double[][], double, double) for each density estimator in <em>listDE</em>, thus evaluating the respective density estimator at the \(k\) points in <em>evalPoints</em> and adds the resulting \(m\times k\) array to <em>listDensity</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listDE</td><td>the list of density estimators. </td></tr>
    <tr><td class="paramname">evalPoints</td><td>the evaluation points. </td></tr>
    <tr><td class="paramname">data</td><td>the two-dimensional array carrying the observations of \(m\) independent realizations of the underlying model. </td></tr>
    <tr><td class="paramname">a</td><td>the left boundary of the interval. </td></tr>
    <tr><td class="paramname">b</td><td>the right boundary of the interval. </td></tr>
    <tr><td class="paramname">listDensity</td><td>a list to which the evaluations at <em>evalPoints</em> of each density estimator in <em>listDE</em> are added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><b>Florian:</b> I kept the return type as "void" instead of "ArrayList&lt;double[][]&gt;" and pass the corresponding list <em>listDensity</em> to allow for more flexibility when working with it. </dd></dl>

</div>
</div>
<a id="a7b223706dc90bab33746a61504e7be95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b223706dc90bab33746a61504e7be95">&#9670;&nbsp;</a></span>plotDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static String plotDensity </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>evalPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>plotTitle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String []&#160;</td>
          <td class="paramname"><em>axisTitles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives a plot of the estimated density. </p>
<p>The \(x\)-values are passed in <em>evalPoints</em> and the \(y\)-values in <em>density</em>. The user may also set the title of the plot via <em>plotTitle</em> as well as the names of the axes via <em>axisTitles</em>. The latter contains the name of the \(x\) axis as first element and the name of the \(y\) axis as second.</p>
<p>The plot itself is returned as a string, which forms a stand-alone LaTex file (including necessary headers) implementing a tikZ picture.</p>
<p>This function merely tailors and simplifies the methods provided by <a class="el" href="classumontreal_1_1ssj_1_1stat_1_1PgfDataTable.html">umontreal.ssj.stat.PgfDataTable</a> for the purpose of plotting a univariate function. If the user seeks to produce more sophisticated plots, please refer to the aforementioned class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evalPoints</td><td>the \(x\)-values. </td></tr>
    <tr><td class="paramname">density</td><td>the \(y\)-values. </td></tr>
    <tr><td class="paramname">plotTitle</td><td>the title of the plot. </td></tr>
    <tr><td class="paramname">axisTitles</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a3a88d2d3720ac775f5953b35ac0a504a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a88d2d3720ac775f5953b35ac0a504a">&#9670;&nbsp;</a></span>roughnessFunctional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double roughnessFunctional </td>
          <td>(</td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimates the roughness functional. </p>
<p class="formulaDsp">
\[ R(g) = \int_a^b g^2(x)\mathrm{d}x\]
</p>
<p>of a function \(g\) over the interval \([a,b]\). This is done via a quadrature rule using predetermined values of \(g\) passed by the user via <em>density</em> as integration nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">density</td><td>the function evaluations. </td></tr>
    <tr><td class="paramname">a</td><td>the left boundary of the interval </td></tr>
    <tr><td class="paramname">b</td><td>the right boundary of the interval </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a77e2151cf49df9f80a4999e0e9e54d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e2151cf49df9f80a4999e0e9e54d55">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract String toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">abstract</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives a short description of the estimator. </p>
<dl class="section return"><dt>Returns</dt><dd>a short description. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>DensityEstimator.java</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
